# 个人 Agent 记忆系统技术架构文档（Python + SurrealDB）

## 1. 文档定位

本文档描述的是“记忆系统”本身，不包含对话生成能力。  
该系统作为独立服务，对外暴露 Memory API，供外部 Agent 调用。

核心约束：

1. 仅使用一个 LLM（记忆 LLM），用于事件理解与记忆提议生成。
2. 记忆写入由系统裁决执行，LLM 不可直接写库。
3. 数据层统一使用 SurrealDB（三合一：文档 + 图 + 向量）。

---

## 2. 系统边界与职责

## 2.1 本系统负责

1. 接收外部 Agent 上报的事件与会话片段。
2. 输出多层记忆检索结果（事实、线索、关系）。
3. 执行记忆提议裁决、升格、降级、撤回。
4. 提供审计与可解释能力（trace）。

## 2.2 本系统不负责

1. 不直接与终端用户对话。
2. 不生成最终回答文本。
3. 不承担业务工作流编排（由外部 Agent 负责）。

## 2.3 身份与租户策略（个人版）

个人版默认采用“单用户、单租户、可选多 Agent”：

1. 对外 API 不强制暴露 `tenant_id/user_id/agent_id/session_id`。
2. 身份由鉴权上下文隐式注入。
3. 服务端内部写入时自动补齐默认值：
- `tenant_id = tenant:default`
- `user_id = user:me`
- `agent_id = agent:default`（可被调用方配置覆盖）
- `session_id` 由系统自动生成或复用 `conversation_id`
4. 后续若升级为 SaaS，多租户字段无需改表，仅需放开 API 入参与鉴权映射。

---

## 3. 总体架构（Python）

## 3.1 组件划分

1. `memory-api`（FastAPI）
- 对外提供标准 Memory API。
- 负责鉴权、请求校验、幂等与限流。

2. `memory-orchestrator`
- 负责写入路径和查询路径编排。
- 协调提议生成、裁决、落库。

3. `memory-llm-adapter`
- 唯一 LLM 接入层。
- 将事件批次转换为结构化记忆提议（JSON）。

4. `arbiter-engine`
- 规则引擎与评分器。
- 决定事件仅归档、写线索、写候选事实或升格事实。

5. `memory-repository`
- SurrealDB 访问层，封装文档/图/向量查询。

6. `memory-worker`
- 异步任务：提议处理、TTL 过期、衰减、冲突检测、重建索引。

## 3.2 运行时选型

1. Python 3.11+
2. FastAPI + Pydantic v2
3. Uvicorn / Gunicorn
4. Arq（推荐）或 Celery 作为异步执行
5. Redis（可选，用于任务队列和短期缓存）
6. OpenTelemetry（链路追踪）

---

## 4. SurrealDB 统一数据模型

说明：以下为逻辑模型，落地阶段可按命名规范调整。
说明：`tenant_id/user_id/agent_id/session_id` 为内部标准字段，个人版由服务端默认注入。

## 4.1 事件层 `event_log`

用途：所有输入先作为事件落盘。

字段：

1. `id`
2. `tenant_id`
3. `agent_id`
4. `user_id`
5. `session_id`
6. `content`
7. `event_type`（utterance/action/feedback/import）
8. `ts`
9. `source`
10. `meta`

## 4.2 线索层 `recall_chunk`

用途：语义召回，不作为裁决依据。

字段：

1. `id`
2. `tenant_id`
3. `user_id`
4. `text`
5. `embedding`
6. `event_ref`
7. `decay_score`
8. `expire_at`
9. `created_at`

## 4.3 候选事实层 `fact_candidate`

用途：待观察、可过期、可升格。

字段：

1. `id`
2. `tenant_id`
3. `user_id`
4. `fact_key`
5. `fact_value`
6. `scope`
7. `confidence`
8. `ttl_seconds`
9. `expire_at`
10. `status`（active/promoted/expired/rejected）
11. `evidence_refs`
12. `created_at`

## 4.4 事实层 `fact_truth`

用途：可对外负责的结论性事实。

字段：

1. `id`
2. `tenant_id`
3. `user_id`
4. `fact_key`
5. `fact_value`
6. `scope`
7. `version`
8. `valid_from`
9. `valid_to`
10. `status`（active/overridden/revoked）
11. `source_trace`
12. `created_at`
13. `updated_at`

## 4.5 结构层 `entity` / `relation`

用途：存储关系约束与上下文结构。

`entity` 字段：

1. `id`
2. `tenant_id`
3. `user_id`
4. `entity_type`（goal/preference/context/concept）
5. `name`
6. `attrs`

`relation` 字段：

1. `id`
2. `tenant_id`
3. `user_id`
4. `from`
5. `to`
6. `rel_type`（depends_on/conflicts_with/applies_in/contains）
7. `weight`
8. `scope`
9. `source_trace`
10. `created_at`

## 4.6 审计层 `audit_log`

用途：记忆动作可追踪、可解释、可回放。

字段：

1. `id`
2. `trace_id`
3. `tenant_id`
4. `user_id`
5. `action`（propose/promote/reject/override/revoke/delete）
6. `target_type`
7. `target_id`
8. `reason`
9. `operator`（system/agent/user）
10. `ts`

---

## 5. 核心流程

## 5.1 写入流程（外部 Agent -> 记忆系统）

1. 外部 Agent 调用 `events.append` 上报事件。
2. 事件写入 `event_log` 并返回 `event_id/trace_id`。
3. 异步触发记忆 LLM 生成结构化提议：
- recall 提议
- fact_candidate 提议
- relation 提议
4. `arbiter-engine` 基于规则裁决动作。
5. `memory-repository` 写入 SurrealDB。
6. 所有动作写入 `audit_log`。

## 5.2 查询流程（外部 Agent -> 记忆系统）

1. 外部 Agent 调用 `memory.query`。
2. 系统并行检索：
- `fact_truth`（按 scope、版本、有效期）
- `recall_chunk`（向量 Top-K）
- `relation`（单跳/多跳）
3. 返回结构化结果与证据引用，不返回自然语言结论。

## 5.3 治理流程（纠错/遗忘）

1. 外部 Agent 或用户代表调用 override/revoke/delete 接口。
2. 系统更新状态（事实版本化，不做硬覆盖）。
3. 同步调整关联关系与候选事实状态。
4. 输出可解释变更记录（通过 `trace_id` 查询）。

---

## 6. 对外 API 设计（V1）

说明：以下接口均面向外部 Agent，接口语义稳定优先。

## 6.1 事件与提议触发

1. `POST /api/v1/events.append`
- 输入（个人版最小）：`content`
- 输入（可选）：`conversation_id, event_type, ts, meta, agent`  
- 输出：`event_id, trace_id, conversation_id, accepted`

2. `POST /api/v1/events.batch_append`
- 输入：事件数组（每项最小仅 `content`）
- 输出：批量 `event_id` 与 `trace_id`

## 6.2 记忆查询

1. `POST /api/v1/memory.query`
- 输入（个人版最小）：`query_text`
- 输入（可选）：`scope, top_k, hops, conversation_id`
- 输出：`facts, recalls, relations, trace_id`

2. `GET /api/v1/memory.facts`
- 输入（可选）：`scope`
- 输出：当前有效事实列表

## 6.3 治理与审计

1. `POST /api/v1/memory.facts/{id}/override`
2. `POST /api/v1/memory.facts/{id}/revoke`
3. `DELETE /api/v1/memory.recalls/{id}`
4. `GET /api/v1/memory.audit/{trace_id}`

---

## 7. 裁决规则（V1）

采用“硬约束 + 评分”双机制。

## 7.1 硬约束

1. 无确认信号不得直接写入 `fact_truth`。
2. 无来源证据不得升格事实。
3. 与现有强事实冲突时仅可进入候选层或拒绝。

## 7.2 评分维度（0-100）

1. 用户确认强度（0-40）
2. 稳定性（0-20）
3. 重复一致性（0-20）
4. 风险惩罚（-20 到 0）

## 7.3 动作阈值（示例）

1. `<30`：仅事件/线索
2. `30-59`：候选事实（TTL）
3. `>=60`：满足硬约束后可升格为事实

---

## 8. 可解释性设计

每个 `trace_id` 至少包含：

1. 输入事件集合（event ids）
2. LLM 提议摘要（结构化）
3. 裁决命中规则
4. 最终写入动作与目标记录 id

外部 Agent 可据此解释“为何形成该记忆”。

---

## 9. 非功能要求

1. 一致性：事实必须版本化更新。
2. 可回滚：撤回操作可恢复历史状态。
3. 可观测：全链路 trace + 指标 + 结构化日志。
4. 隔离策略：个人版默认单租户；升级版开启多租户强隔离。
5. 性能目标（V1）：
- `events.append` P95 < 200ms（不含异步处理）
- `memory.query` P95 < 400ms（不含外部网络）
- 异步提议处理延迟 < 10s

---

## 10. 部署架构（建议）

1. `memory-api`：FastAPI 实例（可横向扩展）
2. `memory-worker`：异步任务执行
3. `surrealdb`：记忆主库（文档/图/向量）
4. `redis`：异步队列（可选）
5. `otel-collector`：观测与追踪

建议环境：

1. 开发：Docker Compose
2. 生产：Kubernetes + HPA（按 QPS 扩缩容）

---

## 11. 实施里程碑

## M1（可集成）

1. 完成核心表：`event_log / recall_chunk / fact_truth / audit_log`
2. 完成 `events.append` 与 `memory.query`
3. 打通单 LLM 提议 + 裁决 + 异步落库
4. 支持事实撤回与审计查询

## M2（稳定化）

1. 候选事实层 `fact_candidate` 生命周期（TTL/降级）
2. 关系图 1-2 跳查询
3. 冲突检测和规则配置化

## M3（治理增强）

1. 批量治理接口（批量撤回/批量过期）
2. 质量评测看板（升格准确率、冲突率、回滚率）
3. 数据冷热分层与归档策略

---

## 12. 风险与缓解

1. 风险：LLM 提议噪声高  
缓解：硬约束优先、候选层 TTL、离线样本评估。

2. 风险：外部 Agent 滥写入  
缓解：鉴权 + 配额 + 幂等键 + schema 校验。

3. 风险：未来升级多租户时字段兼容问题  
缓解：保留内部标准字段，外部 API 按版本渐进放开。

---

## 13. 下一步输出

1. SurrealDB DDL 与索引脚本（含向量索引、关系边）。
2. FastAPI OpenAPI 规范（请求/响应模型）。
3. `arbiter-engine` 规则配置（YAML）与 Python 骨架代码。
